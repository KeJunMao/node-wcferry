{"version":3,"sources":["../../../../../../packages/ws/node_modules/commander/typings/index.d.ts"],"sourcesContent":["// Type definitions for commander\n// Original definitions by: Alan Agius <https://github.com/alan-agius4>, Marcelo Dezem <https://github.com/mdezem>, vvakame <https://github.com/vvakame>, Jules Randolph <https://github.com/sveinburne>\n\n// Using method rather than property for method-signature-style, to document method overloads separately. Allow either.\n/* eslint-disable @typescript-eslint/method-signature-style */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n// This is a trick to encourage editor to suggest the known literals while still\n// allowing any BaseType value.\n// References:\n// - https://github.com/microsoft/TypeScript/issues/29729\n// - https://github.com/sindresorhus/type-fest/blob/main/source/literal-union.d.ts\n// - https://github.com/sindresorhus/type-fest/blob/main/source/primitive.d.ts\ntype LiteralUnion<LiteralType, BaseType extends string | number> = LiteralType | (BaseType & Record<never, never>);\n\nexport class CommanderError extends Error {\n  code: string;\n  exitCode: number;\n  message: string;\n  nestedError?: string;\n\n  /**\n   * Constructs the CommanderError class\n   * @param exitCode - suggested exit code which could be used with process.exit\n   * @param code - an id string representing the error\n   * @param message - human-readable description of the error\n   * @constructor\n   */\n  constructor(exitCode: number, code: string, message: string);\n}\n\nexport class InvalidArgumentError extends CommanderError {\n  /**\n   * Constructs the InvalidArgumentError class\n   * @param message - explanation of why argument is invalid\n   * @constructor\n   */\n  constructor(message: string);\n}\nexport { InvalidArgumentError as InvalidOptionArgumentError }; // deprecated old name\n\nexport interface ErrorOptions { // optional parameter for error()\n  /** an id string representing the error */\n  code?: string;\n  /** suggested exit code which could be used with process.exit */\n  exitCode?: number;\n}\n\nexport class Argument {\n  description: string;\n  required: boolean;\n  variadic: boolean;\n  defaultValue?: any;\n  defaultValueDescription?: string;\n  argChoices?: string[];\n\n  /**\n   * Initialize a new command argument with the given name and description.\n   * The default is that the argument is required, and you can explicitly\n   * indicate this with <> around the name. Put [] around the name for an optional argument.\n   */\n  constructor(arg: string, description?: string);\n\n  /**\n   * Return argument name.\n   */\n  name(): string;\n\n  /**\n   * Set the default value, and optionally supply the description to be displayed in the help.\n   */\n  default(value: unknown, description?: string): this;\n\n  /**\n   * Set the custom handler for processing CLI command arguments into argument values.\n   */\n  argParser<T>(fn: (value: string, previous: T) => T): this;\n\n  /**\n   * Only allow argument value to be one of choices.\n   */\n  choices(values: readonly string[]): this;\n\n  /**\n   * Make argument required.\n   */\n  argRequired(): this;\n\n  /**\n   * Make argument optional.\n   */\n  argOptional(): this;\n}\n\nexport class Option {\n  flags: string;\n  description: string;\n\n  required: boolean; // A value must be supplied when the option is specified.\n  optional: boolean; // A value is optional when the option is specified.\n  variadic: boolean;\n  mandatory: boolean; // The option must have a value after parsing, which usually means it must be specified on command line.\n  short?: string;\n  long?: string;\n  negate: boolean;\n  defaultValue?: any;\n  defaultValueDescription?: string;\n  presetArg?: unknown;\n  envVar?: string;\n  parseArg?: <T>(value: string, previous: T) => T;\n  hidden: boolean;\n  argChoices?: string[];\n\n  constructor(flags: string, description?: string);\n\n  /**\n   * Set the default value, and optionally supply the description to be displayed in the help.\n   */\n  default(value: unknown, description?: string): this;\n\n  /**\n   * Preset to use when option used without option-argument, especially optional but also boolean and negated.\n   * The custom processing (parseArg) is called.\n   *\n   * @example\n   * ```ts\n   * new Option('--color').default('GREYSCALE').preset('RGB');\n   * new Option('--donate [amount]').preset('20').argParser(parseFloat);\n   * ```\n   */\n  preset(arg: unknown): this;\n\n  /**\n   * Add option name(s) that conflict with this option.\n   * An error will be displayed if conflicting options are found during parsing.\n   *\n   * @example\n   * ```ts\n   * new Option('--rgb').conflicts('cmyk');\n   * new Option('--js').conflicts(['ts', 'jsx']);\n   * ```\n   */\n  conflicts(names: string | string[]): this;\n\n  /**\n   * Specify implied option values for when this option is set and the implied options are not.\n   *\n   * The custom processing (parseArg) is not called on the implied values.\n   *\n   * @example\n   * program\n   *   .addOption(new Option('--log', 'write logging information to file'))\n   *   .addOption(new Option('--trace', 'log extra details').implies({ log: 'trace.txt' }));\n   */\n  implies(optionValues: OptionValues): this;\n\n  /**\n   * Set environment variable to check for option value.\n   *\n   * An environment variables is only used if when processed the current option value is\n   * undefined, or the source of the current value is 'default' or 'config' or 'env'.\n   */\n  env(name: string): this;\n\n  /**\n   * Calculate the full description, including defaultValue etc.\n   */\n  fullDescription(): string;\n\n  /**\n   * Set the custom handler for processing CLI option arguments into option values.\n   */\n  argParser<T>(fn: (value: string, previous: T) => T): this;\n\n  /**\n   * Whether the option is mandatory and must have a value after parsing.\n   */\n  makeOptionMandatory(mandatory?: boolean): this;\n\n  /**\n   * Hide option in help.\n   */\n  hideHelp(hide?: boolean): this;\n\n  /**\n   * Only allow option value to be one of choices.\n   */\n  choices(values: readonly string[]): this;\n\n  /**\n   * Return option name.\n   */\n  name(): string;\n\n  /**\n   * Return option name, in a camelcase format that can be used\n   * as a object attribute key.\n   */\n  attributeName(): string;\n\n  /**\n   * Return whether a boolean option.\n   *\n   * Options are one of boolean, negated, required argument, or optional argument.\n   */\n  isBoolean(): boolean;\n}\n\nexport class Help {\n  /** output helpWidth, long lines are wrapped to fit */\n  helpWidth?: number;\n  sortSubcommands: boolean;\n  sortOptions: boolean;\n  showGlobalOptions: boolean;\n\n  constructor();\n\n  /** Get the command term to show in the list of subcommands. */\n  subcommandTerm(cmd: Command): string;\n  /** Get the command summary to show in the list of subcommands. */\n  subcommandDescription(cmd: Command): string;\n  /** Get the option term to show in the list of options. */\n  optionTerm(option: Option): string;\n  /** Get the option description to show in the list of options. */\n  optionDescription(option: Option): string;\n  /** Get the argument term to show in the list of arguments. */\n  argumentTerm(argument: Argument): string;\n  /** Get the argument description to show in the list of arguments. */\n  argumentDescription(argument: Argument): string;\n\n  /** Get the command usage to be displayed at the top of the built-in help. */\n  commandUsage(cmd: Command): string;\n  /** Get the description for the command. */\n  commandDescription(cmd: Command): string;\n\n  /** Get an array of the visible subcommands. Includes a placeholder for the implicit help command, if there is one. */\n  visibleCommands(cmd: Command): Command[];\n  /** Get an array of the visible options. Includes a placeholder for the implicit help option, if there is one. */\n  visibleOptions(cmd: Command): Option[];\n  /** Get an array of the visible global options. (Not including help.) */\n  visibleGlobalOptions(cmd: Command): Option[];\n  /** Get an array of the arguments which have descriptions. */\n  visibleArguments(cmd: Command): Argument[];\n\n  /** Get the longest command term length. */\n  longestSubcommandTermLength(cmd: Command, helper: Help): number;\n  /** Get the longest option term length. */\n  longestOptionTermLength(cmd: Command, helper: Help): number;\n  /** Get the longest global option term length. */\n  longestGlobalOptionTermLength(cmd: Command, helper: Help): number;\n  /** Get the longest argument term length. */\n  longestArgumentTermLength(cmd: Command, helper: Help): number;\n  /** Calculate the pad width from the maximum term length. */\n  padWidth(cmd: Command, helper: Help): number;\n\n  /**\n   * Wrap the given string to width characters per line, with lines after the first indented.\n   * Do not wrap if insufficient room for wrapping (minColumnWidth), or string is manually formatted.\n   */\n  wrap(str: string, width: number, indent: number, minColumnWidth?: number): string;\n\n  /** Generate the built-in help text. */\n  formatHelp(cmd: Command, helper: Help): string;\n}\nexport type HelpConfiguration = Partial<Help>;\n\nexport interface ParseOptions {\n  from: 'node' | 'electron' | 'user';\n}\nexport interface HelpContext { // optional parameter for .help() and .outputHelp()\n  error: boolean;\n}\nexport interface AddHelpTextContext { // passed to text function used with .addHelpText()\n  error: boolean;\n  command: Command;\n}\nexport interface OutputConfiguration {\n  writeOut?(str: string): void;\n  writeErr?(str: string): void;\n  getOutHelpWidth?(): number;\n  getErrHelpWidth?(): number;\n  outputError?(str: string, write: (str: string) => void): void;\n\n}\n\nexport type AddHelpTextPosition = 'beforeAll' | 'before' | 'after' | 'afterAll';\nexport type HookEvent = 'preSubcommand' | 'preAction' | 'postAction';\n// The source is a string so author can define their own too.\nexport type OptionValueSource = LiteralUnion<'default' | 'config' | 'env' | 'cli' | 'implied', string> | undefined;\n\nexport type OptionValues = Record<string, any>;\n\nexport class Command {\n  args: string[];\n  processedArgs: any[];\n  readonly commands: readonly Command[];\n  readonly options: readonly Option[];\n  readonly registeredArguments: readonly Argument[];\n  parent: Command | null;\n\n  constructor(name?: string);\n\n  /**\n   * Set the program version to `str`.\n   *\n   * This method auto-registers the \"-V, --version\" flag\n   * which will print the version number when passed.\n   *\n   * You can optionally supply the  flags and description to override the defaults.\n   */\n  version(str: string, flags?: string, description?: string): this;\n  /**\n   * Get the program version.\n   */\n  version(): string | undefined;\n\n  /**\n   * Define a command, implemented using an action handler.\n   *\n   * @remarks\n   * The command description is supplied using `.description`, not as a parameter to `.command`.\n   *\n   * @example\n   * ```ts\n   * program\n   *   .command('clone <source> [destination]')\n   *   .description('clone a repository into a newly created directory')\n   *   .action((source, destination) => {\n   *     console.log('clone command called');\n   *   });\n   * ```\n   *\n   * @param nameAndArgs - command name and arguments, args are  `<required>` or `[optional]` and last may also be `variadic...`\n   * @param opts - configuration options\n   * @returns new command\n   */\n  command(nameAndArgs: string, opts?: CommandOptions): ReturnType<this['createCommand']>;\n  /**\n   * Define a command, implemented in a separate executable file.\n   *\n   * @remarks\n   * The command description is supplied as the second parameter to `.command`.\n   *\n   * @example\n   * ```ts\n   *  program\n   *    .command('start <service>', 'start named service')\n   *    .command('stop [service]', 'stop named service, or all if no name supplied');\n   * ```\n   *\n   * @param nameAndArgs - command name and arguments, args are  `<required>` or `[optional]` and last may also be `variadic...`\n   * @param description - description of executable command\n   * @param opts - configuration options\n   * @returns `this` command for chaining\n   */\n  command(nameAndArgs: string, description: string, opts?: ExecutableCommandOptions): this;\n\n  /**\n   * Factory routine to create a new unattached command.\n   *\n   * See .command() for creating an attached subcommand, which uses this routine to\n   * create the command. You can override createCommand to customise subcommands.\n   */\n  createCommand(name?: string): Command;\n\n  /**\n   * Add a prepared subcommand.\n   *\n   * See .command() for creating an attached subcommand which inherits settings from its parent.\n   *\n   * @returns `this` command for chaining\n   */\n  addCommand(cmd: Command, opts?: CommandOptions): this;\n\n  /**\n   * Factory routine to create a new unattached argument.\n   *\n   * See .argument() for creating an attached argument, which uses this routine to\n   * create the argument. You can override createArgument to return a custom argument.\n   */\n  createArgument(name: string, description?: string): Argument;\n\n  /**\n   * Define argument syntax for command.\n   *\n   * The default is that the argument is required, and you can explicitly\n   * indicate this with <> around the name. Put [] around the name for an optional argument.\n   *\n   * @example\n   * ```\n   * program.argument('<input-file>');\n   * program.argument('[output-file]');\n   * ```\n   *\n   * @returns `this` command for chaining\n   */\n  argument<T>(flags: string, description: string, fn: (value: string, previous: T) => T, defaultValue?: T): this;\n  argument(name: string, description?: string, defaultValue?: unknown): this;\n\n  /**\n   * Define argument syntax for command, adding a prepared argument.\n   *\n   * @returns `this` command for chaining\n   */\n  addArgument(arg: Argument): this;\n\n  /**\n   * Define argument syntax for command, adding multiple at once (without descriptions).\n   *\n   * See also .argument().\n   *\n   * @example\n   * ```\n   * program.arguments('<cmd> [env]');\n   * ```\n   *\n   * @returns `this` command for chaining\n   */\n  arguments(names: string): this;\n\n  /**\n   * Override default decision whether to add implicit help command.\n   *\n   * @example\n   * ```\n   * addHelpCommand() // force on\n   * addHelpCommand(false); // force off\n   * addHelpCommand('help [cmd]', 'display help for [cmd]'); // force on with custom details\n   * ```\n   *\n   * @returns `this` command for chaining\n   */\n  addHelpCommand(enableOrNameAndArgs?: string | boolean, description?: string): this;\n\n  /**\n   * Add hook for life cycle event.\n   */\n  hook(event: HookEvent, listener: (thisCommand: Command, actionCommand: Command) => void | Promise<void>): this;\n\n  /**\n   * Register callback to use as replacement for calling process.exit.\n   */\n  exitOverride(callback?: (err: CommanderError) => never | void): this;\n\n  /**\n   * Display error message and exit (or call exitOverride).\n   */\n  error(message: string, errorOptions?: ErrorOptions): never;\n\n  /**\n   * You can customise the help with a subclass of Help by overriding createHelp,\n   * or by overriding Help properties using configureHelp().\n   */\n  createHelp(): Help;\n\n  /**\n   * You can customise the help by overriding Help properties using configureHelp(),\n   * or with a subclass of Help by overriding createHelp().\n   */\n  configureHelp(configuration: HelpConfiguration): this;\n  /** Get configuration */\n  configureHelp(): HelpConfiguration;\n\n  /**\n   * The default output goes to stdout and stderr. You can customise this for special\n   * applications. You can also customise the display of errors by overriding outputError.\n   *\n   * The configuration properties are all functions:\n   * ```\n   * // functions to change where being written, stdout and stderr\n   * writeOut(str)\n   * writeErr(str)\n   * // matching functions to specify width for wrapping help\n   * getOutHelpWidth()\n   * getErrHelpWidth()\n   * // functions based on what is being written out\n   * outputError(str, write) // used for displaying errors, and not used for displaying help\n   * ```\n   */\n  configureOutput(configuration: OutputConfiguration): this;\n  /** Get configuration */\n  configureOutput(): OutputConfiguration;\n\n  /**\n   * Copy settings that are useful to have in common across root command and subcommands.\n   *\n   * (Used internally when adding a command using `.command()` so subcommands inherit parent settings.)\n   */\n  copyInheritedSettings(sourceCommand: Command): this;\n\n  /**\n   * Display the help or a custom message after an error occurs.\n   */\n  showHelpAfterError(displayHelp?: boolean | string): this;\n\n  /**\n   * Display suggestion of similar commands for unknown commands, or options for unknown options.\n   */\n  showSuggestionAfterError(displaySuggestion?: boolean): this;\n\n  /**\n   * Register callback `fn` for the command.\n   *\n   * @example\n   * ```\n   * program\n   *   .command('serve')\n   *   .description('start service')\n   *   .action(function() {\n   *     // do work here\n   *   });\n   * ```\n   *\n   * @returns `this` command for chaining\n   */\n  action(fn: (...args: any[]) => void | Promise<void>): this;\n\n  /**\n   * Define option with `flags`, `description`, and optional argument parsing function or `defaultValue` or both.\n   *\n   * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space. A required\n   * option-argument is indicated by `<>` and an optional option-argument by `[]`.\n   *\n   * See the README for more details, and see also addOption() and requiredOption().\n   *\n   * @example\n   *\n   * ```js\n   * program\n   *     .option('-p, --pepper', 'add pepper')\n   *     .option('-p, --pizza-type <TYPE>', 'type of pizza') // required option-argument\n   *     .option('-c, --cheese [CHEESE]', 'add extra cheese', 'mozzarella') // optional option-argument with default\n   *     .option('-t, --tip <VALUE>', 'add tip to purchase cost', parseFloat) // custom parse function\n   * ```\n   *\n   * @returns `this` command for chaining\n   */\n  option(flags: string, description?: string, defaultValue?: string | boolean | string[]): this;\n  option<T>(flags: string, description: string, parseArg: (value: string, previous: T) => T, defaultValue?: T): this;\n  /** @deprecated since v7, instead use choices or a custom function */\n  option(flags: string, description: string, regexp: RegExp, defaultValue?: string | boolean | string[]): this;\n\n  /**\n   * Define a required option, which must have a value after parsing. This usually means\n   * the option must be specified on the command line. (Otherwise the same as .option().)\n   *\n   * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space.\n   */\n  requiredOption(flags: string, description?: string, defaultValue?: string | boolean | string[]): this;\n  requiredOption<T>(flags: string, description: string, parseArg: (value: string, previous: T) => T, defaultValue?: T): this;\n  /** @deprecated since v7, instead use choices or a custom function */\n  requiredOption(flags: string, description: string, regexp: RegExp, defaultValue?: string | boolean | string[]): this;\n\n  /**\n   * Factory routine to create a new unattached option.\n   *\n   * See .option() for creating an attached option, which uses this routine to\n   * create the option. You can override createOption to return a custom option.\n   */\n\n  createOption(flags: string, description?: string): Option;\n\n  /**\n   * Add a prepared Option.\n   *\n   * See .option() and .requiredOption() for creating and attaching an option in a single call.\n   */\n  addOption(option: Option): this;\n\n  /**\n   * Whether to store option values as properties on command object,\n   * or store separately (specify false). In both cases the option values can be accessed using .opts().\n   *\n   * @returns `this` command for chaining\n   */\n  storeOptionsAsProperties<T extends OptionValues>(): this & T;\n  storeOptionsAsProperties<T extends OptionValues>(storeAsProperties: true): this & T;\n  storeOptionsAsProperties(storeAsProperties?: boolean): this;\n\n  /**\n   * Retrieve option value.\n   */\n  getOptionValue(key: string): any;\n\n  /**\n   * Store option value.\n   */\n  setOptionValue(key: string, value: unknown): this;\n\n  /**\n   * Store option value and where the value came from.\n   */\n  setOptionValueWithSource(key: string, value: unknown, source: OptionValueSource): this;\n\n  /**\n   * Get source of option value.\n   */\n  getOptionValueSource(key: string): OptionValueSource | undefined;\n\n  /**\n    * Get source of option value. See also .optsWithGlobals().\n   */\n  getOptionValueSourceWithGlobals(key: string): OptionValueSource | undefined;\n\n  /**\n   * Alter parsing of short flags with optional values.\n   *\n   * @example\n   * ```\n   * // for `.option('-f,--flag [value]'):\n   * .combineFlagAndOptionalValue(true)  // `-f80` is treated like `--flag=80`, this is the default behaviour\n   * .combineFlagAndOptionalValue(false) // `-fb` is treated like `-f -b`\n   * ```\n   *\n   * @returns `this` command for chaining\n   */\n  combineFlagAndOptionalValue(combine?: boolean): this;\n\n  /**\n   * Allow unknown options on the command line.\n   *\n   * @returns `this` command for chaining\n   */\n  allowUnknownOption(allowUnknown?: boolean): this;\n\n  /**\n   * Allow excess command-arguments on the command line. Pass false to make excess arguments an error.\n   *\n   * @returns `this` command for chaining\n   */\n  allowExcessArguments(allowExcess?: boolean): this;\n\n  /**\n   * Enable positional options. Positional means global options are specified before subcommands which lets\n   * subcommands reuse the same option names, and also enables subcommands to turn on passThroughOptions.\n   *\n   * The default behaviour is non-positional and global options may appear anywhere on the command line.\n   *\n   * @returns `this` command for chaining\n   */\n  enablePositionalOptions(positional?: boolean): this;\n\n  /**\n   * Pass through options that come after command-arguments rather than treat them as command-options,\n   * so actual command-options come before command-arguments. Turning this on for a subcommand requires\n   * positional options to have been enabled on the program (parent commands).\n   *\n   * The default behaviour is non-positional and options may appear before or after command-arguments.\n   *\n   * @returns `this` command for chaining\n   */\n  passThroughOptions(passThrough?: boolean): this;\n\n  /**\n   * Parse `argv`, setting options and invoking commands when defined.\n   *\n   * The default expectation is that the arguments are from node and have the application as argv[0]\n   * and the script being run in argv[1], with user parameters after that.\n   *\n   * @example\n   * ```\n   * program.parse(process.argv);\n   * program.parse(); // implicitly use process.argv and auto-detect node vs electron conventions\n   * program.parse(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]\n   * ```\n   *\n   * @returns `this` command for chaining\n   */\n  parse(argv?: readonly string[], options?: ParseOptions): this;\n\n  /**\n   * Parse `argv`, setting options and invoking commands when defined.\n   *\n   * Use parseAsync instead of parse if any of your action handlers are async. Returns a Promise.\n   *\n   * The default expectation is that the arguments are from node and have the application as argv[0]\n   * and the script being run in argv[1], with user parameters after that.\n   *\n   * @example\n   * ```\n   * program.parseAsync(process.argv);\n   * program.parseAsync(); // implicitly use process.argv and auto-detect node vs electron conventions\n   * program.parseAsync(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]\n   * ```\n   *\n   * @returns Promise\n   */\n  parseAsync(argv?: readonly string[], options?: ParseOptions): Promise<this>;\n\n  /**\n   * Parse options from `argv` removing known options,\n   * and return argv split into operands and unknown arguments.\n   *\n   *     argv => operands, unknown\n   *     --known kkk op => [op], []\n   *     op --known kkk => [op], []\n   *     sub --unknown uuu op => [sub], [--unknown uuu op]\n   *     sub -- --unknown uuu op => [sub --unknown uuu op], []\n   */\n  parseOptions(argv: string[]): ParseOptionsResult;\n\n  /**\n   * Return an object containing local option values as key-value pairs\n   */\n  opts<T extends OptionValues>(): T;\n\n  /**\n   * Return an object containing merged local and global option values as key-value pairs.\n   */\n  optsWithGlobals<T extends OptionValues>(): T;\n\n  /**\n   * Set the description.\n   *\n   * @returns `this` command for chaining\n   */\n\n  description(str: string): this;\n  /** @deprecated since v8, instead use .argument to add command argument with description */\n  description(str: string, argsDescription: Record<string, string>): this;\n  /**\n   * Get the description.\n   */\n  description(): string;\n\n  /**\n   * Set the summary. Used when listed as subcommand of parent.\n   *\n   * @returns `this` command for chaining\n   */\n\n  summary(str: string): this;\n  /**\n   * Get the summary.\n   */\n  summary(): string;\n\n  /**\n   * Set an alias for the command.\n   *\n   * You may call more than once to add multiple aliases. Only the first alias is shown in the auto-generated help.\n   *\n   * @returns `this` command for chaining\n   */\n  alias(alias: string): this;\n  /**\n   * Get alias for the command.\n   */\n  alias(): string;\n\n  /**\n   * Set aliases for the command.\n   *\n   * Only the first alias is shown in the auto-generated help.\n   *\n   * @returns `this` command for chaining\n   */\n  aliases(aliases: readonly string[]): this;\n  /**\n   * Get aliases for the command.\n   */\n  aliases(): string[];\n\n  /**\n   * Set the command usage.\n   *\n   * @returns `this` command for chaining\n   */\n  usage(str: string): this;\n  /**\n   * Get the command usage.\n   */\n  usage(): string;\n\n  /**\n   * Set the name of the command.\n   *\n   * @returns `this` command for chaining\n   */\n  name(str: string): this;\n  /**\n   * Get the name of the command.\n   */\n  name(): string;\n\n  /**\n   * Set the name of the command from script filename, such as process.argv[1],\n   * or require.main.filename, or __filename.\n   *\n   * (Used internally and public although not documented in README.)\n   *\n   * @example\n   * ```ts\n   * program.nameFromFilename(require.main.filename);\n   * ```\n   *\n   * @returns `this` command for chaining\n   */\n  nameFromFilename(filename: string): this;\n\n  /**\n   * Set the directory for searching for executable subcommands of this command.\n   *\n   * @example\n   * ```ts\n   * program.executableDir(__dirname);\n   * // or\n   * program.executableDir('subcommands');\n   * ```\n   *\n   * @returns `this` command for chaining\n   */\n  executableDir(path: string): this;\n  /**\n   * Get the executable search directory.\n   */\n  executableDir(): string | null;\n\n  /**\n   * Output help information for this command.\n   *\n   * Outputs built-in help, and custom text added using `.addHelpText()`.\n   *\n   */\n  outputHelp(context?: HelpContext): void;\n  /** @deprecated since v7 */\n  outputHelp(cb?: (str: string) => string): void;\n\n  /**\n   * Return command help documentation.\n   */\n  helpInformation(context?: HelpContext): string;\n\n  /**\n   * You can pass in flags and a description to override the help\n   * flags and help description for your command. Pass in false\n   * to disable the built-in help option.\n   */\n  helpOption(flags?: string | boolean, description?: string): this;\n\n  /**\n   * Output help information and exit.\n   *\n   * Outputs built-in help, and custom text added using `.addHelpText()`.\n   */\n  help(context?: HelpContext): never;\n  /** @deprecated since v7 */\n  help(cb?: (str: string) => string): never;\n\n  /**\n   * Add additional text to be displayed with the built-in help.\n   *\n   * Position is 'before' or 'after' to affect just this command,\n   * and 'beforeAll' or 'afterAll' to affect this command and all its subcommands.\n   */\n  addHelpText(position: AddHelpTextPosition, text: string): this;\n  addHelpText(position: AddHelpTextPosition, text: (context: AddHelpTextContext) => string): this;\n\n  /**\n   * Add a listener (callback) for when events occur. (Implemented using EventEmitter.)\n   */\n  on(event: string | symbol, listener: (...args: any[]) => void): this;\n}\n\nexport interface CommandOptions {\n  hidden?: boolean;\n  isDefault?: boolean;\n  /** @deprecated since v7, replaced by hidden */\n  noHelp?: boolean;\n}\nexport interface ExecutableCommandOptions extends CommandOptions {\n  executableFile?: string;\n}\n\nexport interface ParseOptionsResult {\n  operands: string[];\n  unknown: string[];\n}\n\nexport function createCommand(name?: string): Command;\nexport function createOption(flags: string, description?: string): Option;\nexport function createArgument(name: string, description?: string): Argument;\n\nexport const program: Command;\n"],"names":["Argument","Command","CommanderError","Help","InvalidArgumentError","InvalidOptionArgumentError","Option","program","Error"],"mappings":"AAAA,iCAAiC;AACjC,wMAAwM;AAExM,uHAAuH;AACvH,4DAA4D,GAC5D,qDAAqD,GAErD,gFAAgF;AAChF,+BAA+B;AAC/B,cAAc;AACd,yDAAyD;AACzD,kFAAkF;AAClF,8EAA8E;;;;;;;;;;;;IAoCjEA,QAAQ;eAARA;;IAoPAC,OAAO;eAAPA;;IArRAC,cAAc;eAAdA;;IAiMAC,IAAI;eAAJA;;IAjLAC,oBAAoB;eAApBA;;IAQoBC,0BAA0B;eAAlDD;;IAuDIE,MAAM;eAANA;;IAqxBAC,OAAO;eAAPA;;;AAp2BN,IAAA,AAAML,iBAAN,MAAMA,uBAAuBM;AAcpC;AAEO,IAAA,AAAMJ,uBAAN,MAAMA,6BAA6BF;AAO1C;AAUO,IAAA,AAAMF,WAAN,MAAMA;AA4Cb;AAEO,IAAA,AAAMM,SAAN,MAAMA;AAgHb;AAEO,IAAA,AAAMH,OAAN,MAAMA;AAuDb;AA6BO,IAAA,AAAMF,UAAN,MAAMA;AA0jBb;AAqBO,MAAMM"}