{"version":3,"sources":["../../../../../../packages/ws/node_modules/@types/ws/index.d.ts"],"sourcesContent":["/// <reference types=\"node\" />\n\nimport { EventEmitter } from \"events\";\nimport {\n    Agent,\n    ClientRequest,\n    ClientRequestArgs,\n    IncomingMessage,\n    OutgoingHttpHeaders,\n    Server as HTTPServer,\n} from \"http\";\nimport { Server as HTTPSServer } from \"https\";\nimport { Duplex, DuplexOptions } from \"stream\";\nimport { SecureContextOptions } from \"tls\";\nimport { URL } from \"url\";\nimport { ZlibOptions } from \"zlib\";\n\n// can not get all overload of BufferConstructor['from'], need to copy all it's first arguments here\n// https://github.com/microsoft/TypeScript/issues/32164\ntype BufferLike =\n    | string\n    | Buffer\n    | DataView\n    | number\n    | ArrayBufferView\n    | Uint8Array\n    | ArrayBuffer\n    | SharedArrayBuffer\n    | readonly any[]\n    | readonly number[]\n    | { valueOf(): ArrayBuffer }\n    | { valueOf(): SharedArrayBuffer }\n    | { valueOf(): Uint8Array }\n    | { valueOf(): readonly number[] }\n    | { valueOf(): string }\n    | { [Symbol.toPrimitive](hint: string): string };\n\n// WebSocket socket.\ndeclare class WebSocket extends EventEmitter {\n    /** The connection is not yet open. */\n    static readonly CONNECTING: 0;\n    /** The connection is open and ready to communicate. */\n    static readonly OPEN: 1;\n    /** The connection is in the process of closing. */\n    static readonly CLOSING: 2;\n    /** The connection is closed. */\n    static readonly CLOSED: 3;\n\n    binaryType: \"nodebuffer\" | \"arraybuffer\" | \"fragments\";\n    readonly bufferedAmount: number;\n    readonly extensions: string;\n    /** Indicates whether the websocket is paused */\n    readonly isPaused: boolean;\n    readonly protocol: string;\n    /** The current state of the connection */\n    readonly readyState:\n        | typeof WebSocket.CONNECTING\n        | typeof WebSocket.OPEN\n        | typeof WebSocket.CLOSING\n        | typeof WebSocket.CLOSED;\n    readonly url: string;\n\n    /** The connection is not yet open. */\n    readonly CONNECTING: 0;\n    /** The connection is open and ready to communicate. */\n    readonly OPEN: 1;\n    /** The connection is in the process of closing. */\n    readonly CLOSING: 2;\n    /** The connection is closed. */\n    readonly CLOSED: 3;\n\n    onopen: ((event: WebSocket.Event) => void) | null;\n    onerror: ((event: WebSocket.ErrorEvent) => void) | null;\n    onclose: ((event: WebSocket.CloseEvent) => void) | null;\n    onmessage: ((event: WebSocket.MessageEvent) => void) | null;\n\n    constructor(address: null);\n    constructor(address: string | URL, options?: WebSocket.ClientOptions | ClientRequestArgs);\n    constructor(\n        address: string | URL,\n        protocols?: string | string[],\n        options?: WebSocket.ClientOptions | ClientRequestArgs,\n    );\n\n    close(code?: number, data?: string | Buffer): void;\n    ping(data?: any, mask?: boolean, cb?: (err: Error) => void): void;\n    pong(data?: any, mask?: boolean, cb?: (err: Error) => void): void;\n    // https://github.com/websockets/ws/issues/2076#issuecomment-1250354722\n    send(data: BufferLike, cb?: (err?: Error) => void): void;\n    send(\n        data: BufferLike,\n        options: {\n            mask?: boolean | undefined;\n            binary?: boolean | undefined;\n            compress?: boolean | undefined;\n            fin?: boolean | undefined;\n        },\n        cb?: (err?: Error) => void,\n    ): void;\n    terminate(): void;\n\n    /**\n     * Pause the websocket causing it to stop emitting events. Some events can still be\n     * emitted after this is called, until all buffered data is consumed. This method\n     * is a noop if the ready state is `CONNECTING` or `CLOSED`.\n     */\n    pause(): void;\n    /**\n     * Make a paused socket resume emitting events. This method is a noop if the ready\n     * state is `CONNECTING` or `CLOSED`.\n     */\n    resume(): void;\n\n    // HTML5 WebSocket events\n    addEventListener(\n        method: \"message\",\n        cb: (event: WebSocket.MessageEvent) => void,\n        options?: WebSocket.EventListenerOptions,\n    ): void;\n    addEventListener(\n        method: \"close\",\n        cb: (event: WebSocket.CloseEvent) => void,\n        options?: WebSocket.EventListenerOptions,\n    ): void;\n    addEventListener(\n        method: \"error\",\n        cb: (event: WebSocket.ErrorEvent) => void,\n        options?: WebSocket.EventListenerOptions,\n    ): void;\n    addEventListener(\n        method: \"open\",\n        cb: (event: WebSocket.Event) => void,\n        options?: WebSocket.EventListenerOptions,\n    ): void;\n\n    removeEventListener(method: \"message\", cb: (event: WebSocket.MessageEvent) => void): void;\n    removeEventListener(method: \"close\", cb: (event: WebSocket.CloseEvent) => void): void;\n    removeEventListener(method: \"error\", cb: (event: WebSocket.ErrorEvent) => void): void;\n    removeEventListener(method: \"open\", cb: (event: WebSocket.Event) => void): void;\n\n    // Events\n    on(event: \"close\", listener: (this: WebSocket, code: number, reason: Buffer) => void): this;\n    on(event: \"error\", listener: (this: WebSocket, err: Error) => void): this;\n    on(event: \"upgrade\", listener: (this: WebSocket, request: IncomingMessage) => void): this;\n    on(event: \"message\", listener: (this: WebSocket, data: WebSocket.RawData, isBinary: boolean) => void): this;\n    on(event: \"open\", listener: (this: WebSocket) => void): this;\n    on(event: \"ping\" | \"pong\", listener: (this: WebSocket, data: Buffer) => void): this;\n    on(\n        event: \"unexpected-response\",\n        listener: (this: WebSocket, request: ClientRequest, response: IncomingMessage) => void,\n    ): this;\n    on(event: string | symbol, listener: (this: WebSocket, ...args: any[]) => void): this;\n\n    once(event: \"close\", listener: (this: WebSocket, code: number, reason: Buffer) => void): this;\n    once(event: \"error\", listener: (this: WebSocket, err: Error) => void): this;\n    once(event: \"upgrade\", listener: (this: WebSocket, request: IncomingMessage) => void): this;\n    once(event: \"message\", listener: (this: WebSocket, data: WebSocket.RawData, isBinary: boolean) => void): this;\n    once(event: \"open\", listener: (this: WebSocket) => void): this;\n    once(event: \"ping\" | \"pong\", listener: (this: WebSocket, data: Buffer) => void): this;\n    once(\n        event: \"unexpected-response\",\n        listener: (this: WebSocket, request: ClientRequest, response: IncomingMessage) => void,\n    ): this;\n    once(event: string | symbol, listener: (this: WebSocket, ...args: any[]) => void): this;\n\n    off(event: \"close\", listener: (this: WebSocket, code: number, reason: Buffer) => void): this;\n    off(event: \"error\", listener: (this: WebSocket, err: Error) => void): this;\n    off(event: \"upgrade\", listener: (this: WebSocket, request: IncomingMessage) => void): this;\n    off(event: \"message\", listener: (this: WebSocket, data: WebSocket.RawData, isBinary: boolean) => void): this;\n    off(event: \"open\", listener: (this: WebSocket) => void): this;\n    off(event: \"ping\" | \"pong\", listener: (this: WebSocket, data: Buffer) => void): this;\n    off(\n        event: \"unexpected-response\",\n        listener: (this: WebSocket, request: ClientRequest, response: IncomingMessage) => void,\n    ): this;\n    off(event: string | symbol, listener: (this: WebSocket, ...args: any[]) => void): this;\n\n    addListener(event: \"close\", listener: (code: number, reason: Buffer) => void): this;\n    addListener(event: \"error\", listener: (err: Error) => void): this;\n    addListener(event: \"upgrade\", listener: (request: IncomingMessage) => void): this;\n    addListener(event: \"message\", listener: (data: WebSocket.RawData, isBinary: boolean) => void): this;\n    addListener(event: \"open\", listener: () => void): this;\n    addListener(event: \"ping\" | \"pong\", listener: (data: Buffer) => void): this;\n    addListener(\n        event: \"unexpected-response\",\n        listener: (request: ClientRequest, response: IncomingMessage) => void,\n    ): this;\n    addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n    removeListener(event: \"close\", listener: (code: number, reason: Buffer) => void): this;\n    removeListener(event: \"error\", listener: (err: Error) => void): this;\n    removeListener(event: \"upgrade\", listener: (request: IncomingMessage) => void): this;\n    removeListener(event: \"message\", listener: (data: WebSocket.RawData, isBinary: boolean) => void): this;\n    removeListener(event: \"open\", listener: () => void): this;\n    removeListener(event: \"ping\" | \"pong\", listener: (data: Buffer) => void): this;\n    removeListener(\n        event: \"unexpected-response\",\n        listener: (request: ClientRequest, response: IncomingMessage) => void,\n    ): this;\n    removeListener(event: string | symbol, listener: (...args: any[]) => void): this;\n}\n\ndeclare const WebSocketAlias: typeof WebSocket;\ninterface WebSocketAlias extends WebSocket {} // eslint-disable-line @typescript-eslint/no-empty-interface\n\ndeclare namespace WebSocket {\n    /**\n     * Data represents the raw message payload received over the WebSocket.\n     */\n    type RawData = Buffer | ArrayBuffer | Buffer[];\n\n    /**\n     * Data represents the message payload received over the WebSocket.\n     */\n    type Data = string | Buffer | ArrayBuffer | Buffer[];\n\n    /**\n     * CertMeta represents the accepted types for certificate & key data.\n     */\n    type CertMeta = string | string[] | Buffer | Buffer[];\n\n    /**\n     * VerifyClientCallbackSync is a synchronous callback used to inspect the\n     * incoming message. The return value (boolean) of the function determines\n     * whether or not to accept the handshake.\n     */\n    type VerifyClientCallbackSync<Request extends IncomingMessage = IncomingMessage> = (info: {\n        origin: string;\n        secure: boolean;\n        req: Request;\n    }) => boolean;\n\n    /**\n     * VerifyClientCallbackAsync is an asynchronous callback used to inspect the\n     * incoming message. The return value (boolean) of the function determines\n     * whether or not to accept the handshake.\n     */\n    type VerifyClientCallbackAsync<Request extends IncomingMessage = IncomingMessage> = (\n        info: { origin: string; secure: boolean; req: Request },\n        callback: (res: boolean, code?: number, message?: string, headers?: OutgoingHttpHeaders) => void,\n    ) => void;\n\n    interface ClientOptions extends SecureContextOptions {\n        protocol?: string | undefined;\n        followRedirects?: boolean | undefined;\n        generateMask?(mask: Buffer): void;\n        handshakeTimeout?: number | undefined;\n        maxRedirects?: number | undefined;\n        perMessageDeflate?: boolean | PerMessageDeflateOptions | undefined;\n        localAddress?: string | undefined;\n        protocolVersion?: number | undefined;\n        headers?: { [key: string]: string } | undefined;\n        origin?: string | undefined;\n        agent?: Agent | undefined;\n        host?: string | undefined;\n        family?: number | undefined;\n        checkServerIdentity?(servername: string, cert: CertMeta): boolean;\n        rejectUnauthorized?: boolean | undefined;\n        maxPayload?: number | undefined;\n        skipUTF8Validation?: boolean | undefined;\n    }\n\n    interface PerMessageDeflateOptions {\n        serverNoContextTakeover?: boolean | undefined;\n        clientNoContextTakeover?: boolean | undefined;\n        serverMaxWindowBits?: number | undefined;\n        clientMaxWindowBits?: number | undefined;\n        zlibDeflateOptions?: {\n            flush?: number | undefined;\n            finishFlush?: number | undefined;\n            chunkSize?: number | undefined;\n            windowBits?: number | undefined;\n            level?: number | undefined;\n            memLevel?: number | undefined;\n            strategy?: number | undefined;\n            dictionary?: Buffer | Buffer[] | DataView | undefined;\n            info?: boolean | undefined;\n        } | undefined;\n        zlibInflateOptions?: ZlibOptions | undefined;\n        threshold?: number | undefined;\n        concurrencyLimit?: number | undefined;\n    }\n\n    interface Event {\n        type: string;\n        target: WebSocket;\n    }\n\n    interface ErrorEvent {\n        error: any;\n        message: string;\n        type: string;\n        target: WebSocket;\n    }\n\n    interface CloseEvent {\n        wasClean: boolean;\n        code: number;\n        reason: string;\n        type: string;\n        target: WebSocket;\n    }\n\n    interface MessageEvent {\n        data: Data;\n        type: string;\n        target: WebSocket;\n    }\n\n    interface EventListenerOptions {\n        once?: boolean | undefined;\n    }\n\n    interface ServerOptions<\n        U extends typeof WebSocket.WebSocket = typeof WebSocket.WebSocket,\n        V extends typeof IncomingMessage = typeof IncomingMessage,\n    > {\n        host?: string | undefined;\n        port?: number | undefined;\n        backlog?: number | undefined;\n        server?: HTTPServer<V> | HTTPSServer<V> | undefined;\n        verifyClient?:\n            | VerifyClientCallbackAsync<InstanceType<V>>\n            | VerifyClientCallbackSync<InstanceType<V>>\n            | undefined;\n        handleProtocols?: (protocols: Set<string>, request: InstanceType<V>) => string | false;\n        path?: string | undefined;\n        noServer?: boolean | undefined;\n        clientTracking?: boolean | undefined;\n        perMessageDeflate?: boolean | PerMessageDeflateOptions | undefined;\n        maxPayload?: number | undefined;\n        skipUTF8Validation?: boolean | undefined;\n        WebSocket?: U | undefined;\n    }\n\n    interface AddressInfo {\n        address: string;\n        family: string;\n        port: number;\n    }\n\n    // WebSocket Server\n    class Server<\n        T extends typeof WebSocket.WebSocket = typeof WebSocket.WebSocket,\n        U extends typeof IncomingMessage = typeof IncomingMessage,\n    > extends EventEmitter {\n        options: ServerOptions<T, U>;\n        path: string;\n        clients: Set<InstanceType<T>>;\n\n        constructor(options?: ServerOptions<T, U>, callback?: () => void);\n\n        address(): AddressInfo | string;\n        close(cb?: (err?: Error) => void): void;\n        handleUpgrade(\n            request: InstanceType<U>,\n            socket: Duplex,\n            upgradeHead: Buffer,\n            callback: (client: InstanceType<T>, request: InstanceType<U>) => void,\n        ): void;\n        shouldHandle(request: InstanceType<U>): boolean | Promise<boolean>;\n\n        // Events\n        on(event: \"connection\", cb: (this: Server<T>, socket: InstanceType<T>, request: InstanceType<U>) => void): this;\n        on(event: \"error\", cb: (this: Server<T>, error: Error) => void): this;\n        on(event: \"headers\", cb: (this: Server<T>, headers: string[], request: InstanceType<U>) => void): this;\n        on(event: \"close\" | \"listening\", cb: (this: Server<T>) => void): this;\n        on(event: string | symbol, listener: (this: Server<T>, ...args: any[]) => void): this;\n\n        once(\n            event: \"connection\",\n            cb: (this: Server<T>, socket: InstanceType<T>, request: InstanceType<U>) => void,\n        ): this;\n        once(event: \"error\", cb: (this: Server<T>, error: Error) => void): this;\n        once(event: \"headers\", cb: (this: Server<T>, headers: string[], request: InstanceType<U>) => void): this;\n        once(event: \"close\" | \"listening\", cb: (this: Server<T>) => void): this;\n        once(event: string | symbol, listener: (this: Server<T>, ...args: any[]) => void): this;\n\n        off(\n            event: \"connection\",\n            cb: (this: Server<T>, socket: InstanceType<T>, request: InstanceType<U>) => void,\n        ): this;\n        off(event: \"error\", cb: (this: Server<T>, error: Error) => void): this;\n        off(event: \"headers\", cb: (this: Server<T>, headers: string[], request: InstanceType<U>) => void): this;\n        off(event: \"close\" | \"listening\", cb: (this: Server<T>) => void): this;\n        off(event: string | symbol, listener: (this: Server<T>, ...args: any[]) => void): this;\n\n        addListener(event: \"connection\", cb: (client: InstanceType<T>, request: InstanceType<U>) => void): this;\n        addListener(event: \"error\", cb: (err: Error) => void): this;\n        addListener(event: \"headers\", cb: (headers: string[], request: InstanceType<U>) => void): this;\n        addListener(event: \"close\" | \"listening\", cb: () => void): this;\n        addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        removeListener(event: \"connection\", cb: (client: InstanceType<T>, request: InstanceType<U>) => void): this;\n        removeListener(event: \"error\", cb: (err: Error) => void): this;\n        removeListener(event: \"headers\", cb: (headers: string[], request: InstanceType<U>) => void): this;\n        removeListener(event: \"close\" | \"listening\", cb: () => void): this;\n        removeListener(event: string | symbol, listener: (...args: any[]) => void): this;\n    }\n\n    const WebSocketServer: typeof Server;\n    interface WebSocketServer extends Server {} // eslint-disable-line @typescript-eslint/no-empty-interface\n    const WebSocket: typeof WebSocketAlias;\n    interface WebSocket extends WebSocketAlias {} // eslint-disable-line @typescript-eslint/no-empty-interface\n\n    // WebSocket stream\n    function createWebSocketStream(websocket: WebSocket, options?: DuplexOptions): Duplex;\n}\n\nexport = WebSocket;\n"],"names":["WebSocket"],"mappings":"AAAA,8BAA8B;;wBAED;iBAuZpBA"}