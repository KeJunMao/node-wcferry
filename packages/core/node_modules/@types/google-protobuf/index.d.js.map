{"version":3,"sources":["../../../../../../packages/core/node_modules/@types/google-protobuf/index.d.ts"],"sourcesContent":["type ByteSource = ArrayBuffer | Uint8Array | number[] | string;\ntype ScalarFieldType = boolean | number | string;\ntype RepeatedFieldType = ScalarFieldType[] | Uint8Array[];\ntype AnyFieldType = ScalarFieldType | RepeatedFieldType | Uint8Array;\ntype FieldValue = string | number | boolean | Uint8Array | FieldValueArray | undefined;\ninterface FieldValueArray extends Array<FieldValue> {}\ntype ReadonlyFieldValue = string | number | boolean | Uint8Array | ReadonlyFieldValueArray | undefined;\ninterface ReadonlyFieldValueArray extends ReadonlyArray<FieldValue> {}\n\nexport abstract class Message {\n    getJsPbMessageId(): string | undefined;\n    static initialize(\n        msg: Message,\n        data: Message.MessageArray,\n        messageId: string | number,\n        suggestedPivot: number,\n        repeatedFields?: number[] | null,\n        oneofFields?: number[][] | null,\n    ): void;\n    static toObjectList<T extends Message>(\n        field: T[],\n        toObjectFn: (includeInstance: boolean, data: T) => {},\n        includeInstance?: boolean,\n    ): Array<{}>;\n    static toObjectExtension(\n        msg: Message,\n        obj: {},\n        extensions: { [key: number]: ExtensionFieldInfo<Message> },\n        getExtensionFn: (fieldInfo: ExtensionFieldInfo<Message>) => Message,\n        includeInstance?: boolean,\n    ): void;\n    serializeBinaryExtensions(\n        proto: Message,\n        writer: BinaryWriter,\n        extensions: { [key: number]: ExtensionFieldBinaryInfo<Message> },\n        getExtensionFn: <T>(fieldInfo: ExtensionFieldInfo<T>) => T,\n    ): void;\n    readBinaryExtension(\n        proto: Message,\n        reader: BinaryReader,\n        extensions: { [key: number]: ExtensionFieldBinaryInfo<Message> },\n        setExtensionFn: <T>(fieldInfo: ExtensionFieldInfo<T>, val: T) => void,\n    ): void;\n    static getField(msg: Message, fieldNumber: number): FieldValue | null;\n    static getOptionalFloatingPointField(msg: Message, fieldNumber: number): number | undefined;\n    static getRepeatedFloatingPointField(msg: Message, fieldNumber: number): number[];\n    static bytesAsB64(bytes: Uint8Array): string;\n    static bytesAsU8(str: string): Uint8Array;\n    static bytesListAsB64(bytesList: Uint8Array[]): string[];\n    static bytesListAsU8(strList: string[]): Uint8Array[];\n    static getFieldWithDefault<T>(msg: Message, fieldNumber: number, defaultValue: T): T;\n    static getMapField(\n        msg: Message,\n        fieldNumber: number,\n        noLazyCreate: boolean,\n        valueCtor?: typeof Message,\n    ): Map<any, any>;\n    static setField(\n        msg: Message,\n        fieldNumber: number,\n        value: ReadonlyFieldValue,\n    ): void;\n    static addToRepeatedField(\n        msg: Message,\n        fieldNumber: number,\n        value: any,\n        index?: number,\n    ): void;\n    static setOneofField(\n        msg: Message,\n        fieldNumber: number,\n        oneof: number[],\n        value: ReadonlyFieldValue,\n    ): void;\n    static computeOneofCase(msg: Message, oneof: number[]): number;\n    static getWrapperField<T extends Message>(\n        msg: Message,\n        ctor: { new(): T },\n        fieldNumber: number,\n        required?: number,\n    ): T;\n    static getRepeatedWrapperField<T extends Message>(\n        msg: Message,\n        ctor: { new(): T },\n        fieldNumber: number,\n    ): T[];\n    static setWrapperField<T extends Message>(\n        msg: Message,\n        fieldNumber: number,\n        value?: T | Map<any, any>,\n    ): void;\n    static setOneofWrapperField(\n        msg: Message,\n        fieldNumber: number,\n        oneof: number[],\n        value: any,\n    ): void;\n    static setRepeatedWrapperField<T extends Message>(\n        msg: Message,\n        fieldNumber: number,\n        value?: readonly T[],\n    ): void;\n    static addToRepeatedWrapperField<T extends Message>(\n        msg: Message,\n        fieldNumber: number,\n        value: T | undefined,\n        ctor: { new(): T },\n        index?: number,\n    ): T;\n    static toMap(\n        field: any[],\n        mapKeyGetterFn: (field: any) => string,\n        toObjectFn?: Message.StaticToObject,\n        includeInstance?: boolean,\n    ): void;\n    toArray(): Message.MessageArray;\n    toString(): string;\n    getExtension<T>(fieldInfo: ExtensionFieldInfo<T>): T;\n    setExtension<T>(fieldInfo: ExtensionFieldInfo<T>, value: T): void;\n    static difference<T extends Message>(m1: T, m2: T): T;\n    static equals(m1: Message, m2: Message): boolean;\n    static compareExtensions(extension1: {}, extension2: {}): boolean;\n    static compareFields(field1: any, field2: any): boolean;\n    cloneMessage(): this;\n    clone(): this;\n    static clone<T extends Message>(msg: T): T;\n    static cloneMessage<T extends Message>(msg: T): T;\n    static copyInto(fromMessage: Message, toMessage: Message): void;\n    static registerMessageType(id: number, constructor: typeof Message): void;\n\n    abstract serializeBinary(): Uint8Array;\n    abstract toObject(includeInstance?: boolean): {};\n\n    // These are `abstract static`, but that isn't allowed. Subclasses of Message will have these methods and properties\n    // and not having them on Message makes using this class for its intended purpose quite difficult.\n    static deserializeBinary(bytes: Uint8Array): Message;\n    static deserializeBinaryFromReader(message: Message, reader: BinaryReader): Message;\n    static serializeBinaryToWriter(message: Message, writer: BinaryWriter): void;\n    static toObject(includeInstance: boolean, msg: Message): {};\n    static extensions: { [key: number]: ExtensionFieldInfo<Message> };\n    static extensionsBinary: { [key: number]: ExtensionFieldBinaryInfo<Message> };\n}\n\nexport namespace Message {\n    type MessageArray = any[]; // This type needs to reference itself\n    type StaticToObject = (includeInstance: boolean, msg: Message) => {};\n}\n\nexport class ExtensionFieldInfo<T> {\n    fieldIndex: number;\n    fieldName: number;\n    ctor: typeof Message;\n    toObjectFn: Message.StaticToObject;\n    isRepeated: number;\n    constructor(\n        fieldIndex: number,\n        fieldName: { [key: string]: number },\n        ctor: typeof Message,\n        toObjectFn: Message.StaticToObject,\n        isRepeated: number,\n    );\n    isMessageType(): boolean;\n}\n\nexport class ExtensionFieldBinaryInfo<T> {\n    fieldInfo: ExtensionFieldInfo<T>;\n    binaryReaderFn: BinaryRead;\n    binaryWriterFn: BinaryWrite;\n    opt_binaryMessageSerializeFn: (msg: Message, writer: BinaryWriter) => void;\n    opt_binaryMessageDeserializeFn: (msg: Message, reader: BinaryReader) => Message;\n    opt_isPacked: boolean;\n    constructor(\n        fieldInfo: ExtensionFieldInfo<T>,\n        binaryReaderFn: BinaryRead,\n        binaryWriterFn: BinaryWrite,\n        opt_binaryMessageSerializeFn: (msg: Message, writer: BinaryWriter) => void,\n        opt_binaryMessageDeserializeFn: (msg: Message, reader: BinaryReader) => Message,\n        opt_isPacked: boolean,\n    );\n}\n\nexport class Map<K, V> {\n    constructor(\n        arr: Array<[K, V]>,\n        valueCtor?: { new(init: any): V },\n    );\n    toArray(): Array<[K, V]>;\n    toObject(includeInstance?: boolean): Array<[K, V]>;\n    toObject<VO>(\n        includeInstance: boolean,\n        valueToObject: (includeInstance: boolean, valueWrapper: V) => VO,\n    ): Array<[K, VO]>;\n    static fromObject<TK, TV>(\n        entries: Array<[TK, TV]>,\n        valueCtor: any,\n        valueFromObject: any,\n    ): Map<TK, TV>;\n    getLength(): number;\n    clear(): void;\n    del(key: K): boolean;\n    getEntryList(): Array<[K, V]>;\n    entries(): Map.Iterator<[K, V]>;\n    keys(): Map.Iterator<K>;\n    values(): Map.Iterator<V>;\n    forEach(\n        callback: (entry: V, key: K) => void,\n        thisArg?: {},\n    ): void;\n    set(key: K, value: V): this;\n    get(key: K): V | undefined;\n    has(key: K): boolean;\n    serializeBinary(\n        fieldNumber: number,\n        writer: BinaryWriter,\n        keyWriterFn: (field: number, key: K) => void,\n        valueWriterFn: (field: number, value: V, writerCallback: BinaryWriteCallback) => void,\n        writeCallback?: BinaryWriteCallback,\n    ): void;\n    static deserializeBinary<K, V>(\n        map: Map<K, V>,\n        reader: BinaryReader,\n        keyReaderFn: (reader: BinaryReader) => K,\n        valueReaderFn: (reader: BinaryReader, value: any, readerCallback: BinaryReadCallback) => V,\n        readCallback?: BinaryReadCallback,\n        defaultKey?: K,\n        defaultValue?: V,\n    ): void;\n}\n\nexport namespace Map {\n    // This is implemented by jspb.Map.ArrayIteratorIterable_, but that class shouldn't be exported\n    interface Iterator<T> {\n        [Symbol.iterator](): Iterator<T>;\n        next(): IteratorResult<T>;\n    }\n    interface IteratorResult<T> {\n        done: boolean;\n        value: T;\n    }\n}\n\ntype BinaryReadReader = (msg: any, binaryReader: BinaryReader) => void;\n\ntype BinaryRead = (msg: any, reader: BinaryReadReader) => any;\n\ntype BinaryReadCallback = (value: any, binaryReader: BinaryReader) => void;\n\ntype BinaryWriteCallback = (value: any, binaryWriter: BinaryWriter) => void;\n\ntype BinaryWrite = (fieldNumber: number, value: any, writerCallback: BinaryWriteCallback) => void;\n\nexport class BinaryReader {\n    constructor(bytes?: ByteSource, start?: number, length?: number);\n    static alloc(bytes?: ByteSource, start?: number, length?: number): BinaryReader;\n    alloc(bytes?: ByteSource, start?: number, length?: number): BinaryReader;\n    free(): void;\n    getFieldCursor(): number;\n    getCursor(): number;\n    getBuffer(): Uint8Array;\n    getFieldNumber(): number;\n    getWireType(): BinaryConstants.WireType;\n    isDelimited(): boolean;\n    isEndGroup(): boolean;\n    getError(): boolean;\n    setBlock(bytes?: ByteSource, start?: number, length?: number): void;\n    reset(): void;\n    advance(count: number): void;\n    nextField(): boolean;\n    unskipHeader(): void;\n    skipMatchingFields(): void;\n    skipVarintField(): void;\n    skipDelimitedField(): void;\n    skipFixed32Field(): void;\n    skipFixed64Field(): void;\n    skipGroup(): void;\n    skipField(): void;\n    registerReadCallback(callbackName: string, callback: (binaryReader: BinaryReader) => any): void;\n    runReadCallback(callbackName: string): any;\n    readAny(fieldType: BinaryConstants.FieldType): AnyFieldType;\n    readMessage: BinaryRead;\n    readGroup(field: number, message: Message, reader: BinaryReadReader): void;\n    getFieldDecoder(): BinaryDecoder;\n    readInt32(): number;\n    readInt32String(): string;\n    readInt64(): number;\n    readInt64String(): string;\n    readUint32(): number;\n    readUint32String(): string;\n    readUint64(): number;\n    readUint64String(): string;\n    readSint32(): number;\n    readSint64(): number;\n    readSint64String(): string;\n    readFixed32(): number;\n    readFixed64(): number;\n    readFixed64String(): string;\n    readSfixed32(): number;\n    readSfixed32String(): string;\n    readSfixed64(): number;\n    readSfixed64String(): string;\n    readFloat(): number;\n    readDouble(): number;\n    readBool(): boolean;\n    readEnum(): number;\n    readString(): string;\n    readBytes(): Uint8Array;\n    readVarintHash64(): string;\n    readFixedHash64(): string;\n    readPackedInt32(): number[];\n    readPackedInt32String(): string[];\n    readPackedInt64(): number[];\n    readPackedInt64String(): string[];\n    readPackedUint32(): number[];\n    readPackedUint32String(): string[];\n    readPackedUint64(): number[];\n    readPackedUint64String(): string[];\n    readPackedSint32(): number[];\n    readPackedSint64(): number[];\n    readPackedSint64String(): string[];\n    readPackedFixed32(): number[];\n    readPackedFixed64(): number[];\n    readPackedFixed64String(): string[];\n    readPackedSfixed32(): number[];\n    readPackedSfixed64(): number[];\n    readPackedSfixed64String(): string[];\n    readPackedFloat(): number[];\n    readPackedDouble(): number[];\n    readPackedBool(): boolean[];\n    readPackedEnum(): number[];\n    readPackedVarintHash64(): string[];\n    readPackedFixedHash64(): string[];\n}\n\nexport class BinaryWriter {\n    constructor();\n    writeSerializedMessage(bytes: Uint8Array, start: number, end: number): void;\n    maybeWriteSerializedMessage(bytes?: Uint8Array, start?: number, end?: number): void;\n    reset(): void;\n    getResultBuffer(): Uint8Array;\n    getResultBase64String(): string;\n    beginSubMessage(field: number): void;\n    endSubMessage(field: number): void;\n    writeAny(fieldType: BinaryConstants.FieldType, field: number, value: AnyFieldType): void;\n    writeInt32(field: number, value?: number): void;\n    writeInt32String(field: number, value?: string): void;\n    writeInt64(field: number, value?: number): void;\n    writeInt64String(field: number, value?: string): void;\n    writeUint32(field: number, value?: number): void;\n    writeUint32String(field: number, value?: string): void;\n    writeUint64(field: number, value?: number): void;\n    writeUint64String(field: number, value?: string): void;\n    writeSint32(field: number, value?: number): void;\n    writeSint64(field: number, value?: number): void;\n    writeSint64String(field: number, value?: string): void;\n    writeFixed32(field: number, value?: number): void;\n    writeFixed64(field: number, value?: number): void;\n    writeFixed64String(field: number, value?: string): void;\n    writeSfixed32(field: number, value?: number): void;\n    writeSfixed64(field: number, value?: number): void;\n    writeSfixed64String(field: number, value?: string): void;\n    writeFloat(field: number, value?: number): void;\n    writeDouble(field: number, value?: number): void;\n    writeBool(field: number, value?: boolean): void;\n    writeEnum(field: number, value?: number): void;\n    writeString(field: number, value?: string): void;\n    writeBytes(field: number, value?: ByteSource): void;\n    writeMessage: BinaryWrite;\n    writeGroup(field: number, value: any, writeCallback: BinaryWriteCallback): void;\n    writeFixedHash64(field: number, value?: string): void;\n    writeVarintHash64(field: number, value?: string): void;\n    writeRepeatedInt32(field: number, value?: readonly number[]): void;\n    writeRepeatedInt32String(field: number, value?: readonly string[]): void;\n    writeRepeatedInt64(field: number, value?: readonly number[]): void;\n    writeRepeatedInt64String(field: number, value?: readonly string[]): void;\n    writeRepeatedUint32(field: number, value?: readonly number[]): void;\n    writeRepeatedUint32String(field: number, value?: readonly string[]): void;\n    writeRepeatedUint64(field: number, value?: readonly number[]): void;\n    writeRepeatedUint64String(field: number, value?: readonly string[]): void;\n    writeRepeatedSint32(field: number, value?: readonly number[]): void;\n    writeRepeatedSint64(field: number, value?: readonly number[]): void;\n    writeRepeatedSint64String(field: number, value?: readonly string[]): void;\n    writeRepeatedFixed32(field: number, value?: readonly number[]): void;\n    writeRepeatedFixed64(field: number, value?: readonly number[]): void;\n    writeRepeatedFixed64String(field: number, value?: readonly string[]): void;\n    writeRepeatedSfixed32(field: number, value?: readonly number[]): void;\n    writeRepeatedSfixed64(field: number, value?: readonly number[]): void;\n    writeRepeatedSfixed64String(field: number, value?: readonly string[]): void;\n    writeRepeatedFloat(field: number, value?: readonly number[]): void;\n    writeRepeatedDouble(field: number, value?: readonly number[]): void;\n    writeRepeatedBool(field: number, value?: readonly boolean[]): void;\n    writeRepeatedEnum(field: number, value?: readonly number[]): void;\n    writeRepeatedString(field: number, value?: readonly string[]): void;\n    writeRepeatedBytes(field: number, value?: readonly ByteSource[]): void;\n    writeRepeatedMessage(field: number, value: readonly Message[], writerCallback: BinaryWriteCallback): void;\n    writeRepeatedGroup(field: number, value: readonly Message[], writerCallback: BinaryWriteCallback): void;\n    writeRepeatedFixedHash64(field: number, value?: readonly string[]): void;\n    writeRepeatedVarintHash64(field: number, value?: readonly string[]): void;\n    writePackedInt32(field: number, value?: readonly number[]): void;\n    writePackedInt32String(field: number, value?: readonly string[]): void;\n    writePackedInt64(field: number, value?: readonly number[]): void;\n    writePackedInt64String(field: number, value?: readonly string[]): void;\n    writePackedUint32(field: number, value?: readonly number[]): void;\n    writePackedUint32String(field: number, value?: readonly string[]): void;\n    writePackedUint64(field: number, value?: readonly number[]): void;\n    writePackedUint64String(field: number, value?: readonly string[]): void;\n    writePackedSint32(field: number, value?: readonly number[]): void;\n    writePackedSint64(field: number, value?: readonly number[]): void;\n    writePackedSint64String(field: number, value?: readonly string[]): void;\n    writePackedFixed32(field: number, value?: readonly number[]): void;\n    writePackedFixed64(field: number, value?: readonly number[]): void;\n    writePackedFixed64String(field: number, value?: readonly string[]): void;\n    writePackedSfixed32(field: number, value?: readonly number[]): void;\n    writePackedSfixed64(field: number, value?: readonly number[]): void;\n    writePackedSfixed64String(field: number, value?: readonly string[]): void;\n    writePackedFloat(field: number, value?: readonly number[]): void;\n    writePackedDouble(field: number, value?: readonly number[]): void;\n    writePackedBool(field: number, value?: readonly boolean[]): void;\n    writePackedEnum(field: number, value?: readonly number[]): void;\n    writePackedFixedHash64(field: number, value?: readonly string[]): void;\n    writePackedVarintHash64(field: number, value?: readonly string[]): void;\n}\n\nexport class BinaryEncoder {\n    constructor();\n    length(): number;\n    end(): number[];\n    writeSplitVarint64(lowBits: number, highBits: number): void;\n    writeSplitFixed64(lowBits: number, highBits: number): void;\n    writeUnsignedVarint32(value: number): void;\n    writeSignedVarint32(value: number): void;\n    writeUnsignedVarint64(value: number): void;\n    writeSignedVarint64(value: number): void;\n    writeZigzagVarint32(value: number): void;\n    writeZigzagVarint64(value: number): void;\n    writeZigzagVarint64String(value: string): void;\n    writeUint8(value: number): void;\n    writeUint16(value: number): void;\n    writeUint32(value: number): void;\n    writeUint64(value: number): void;\n    writeInt8(value: number): void;\n    writeInt16(value: number): void;\n    writeInt32(value: number): void;\n    writeInt64(value: number): void;\n    writeInt64String(value: string): void;\n    writeFloat(value: number): void;\n    writeDouble(value: number): void;\n    writeBool(value: boolean): void;\n    writeEnum(value: number): void;\n    writeBytes(bytes: Uint8Array): void;\n    writeVarintHash64(hash: string): void;\n    writeFixedHash64(hash: string): void;\n    writeString(value: string): number;\n}\n\nexport class BinaryDecoder {\n    constructor(bytes?: ByteSource, start?: number, length?: number);\n    static alloc(bytes?: ByteSource, start?: number, length?: number): BinaryDecoder;\n    free(): void;\n    clone(): BinaryDecoder;\n    clear(): void;\n    getBuffer(): Uint8Array;\n    setBlock(data: ByteSource, start?: number, length?: number): void;\n    getEnd(): number;\n    setEnd(end: number): void;\n    reset(): void;\n    getCursor(): number;\n    setCursor(cursor: number): void;\n    advance(count: number): void;\n    atEnd(): boolean;\n    pastEnd(): boolean;\n    getError(): boolean;\n    skipVarint(): void;\n    unskipVarint(value: number): void;\n    readUnsignedVarint32(): number;\n    readSignedVarint32(): number;\n    readUnsignedVarint32String(): number;\n    readSignedVarint32String(): number;\n    readZigzagVarint32(): number;\n    readUnsignedVarint64(): number;\n    readUnsignedVarint64String(): number;\n    readSignedVarint64(): number;\n    readSignedVarint64String(): number;\n    readZigzagVarint64(): number;\n    readZigzagVarint64String(): number;\n    readUint8(): number;\n    readUint16(): number;\n    readUint32(): number;\n    readUint64(): number;\n    readUint64String(): string;\n    readInt8(): number;\n    readInt16(): number;\n    readInt32(): number;\n    readInt64(): number;\n    readInt64String(): string;\n    readFloat(): number;\n    readDouble(): number;\n    readBool(): boolean;\n    readEnum(): number;\n    readString(length: number): string;\n    readStringWithLength(): string;\n    readBytes(length: number): Uint8Array;\n    readVarintHash64(): string;\n    readFixedHash64(): string;\n}\n\nexport class BinaryIterator {\n    constructor(\n        decoder?: BinaryDecoder,\n        next?: () => number | boolean | string | null,\n        elements?: Array<number | boolean | string>,\n    );\n    static alloc(\n        decoder?: BinaryDecoder,\n        next?: () => number | boolean | string | null,\n        elements?: Array<number | boolean | string>,\n    ): BinaryIterator;\n    free(): void;\n    clear(): void;\n    get(): ScalarFieldType | null;\n    atEnd(): boolean;\n    next(): ScalarFieldType | null;\n}\n\nexport namespace BinaryConstants {\n    enum FieldType {\n        INVALID = -1,\n        DOUBLE = 1,\n        FLOAT = 2,\n        INT64 = 3,\n        UINT64 = 4,\n        INT32 = 5,\n        FIXED64 = 6,\n        FIXED32 = 7,\n        BOOL = 8,\n        STRING = 9,\n        GROUP = 10,\n        MESSAGE = 11,\n        BYTES = 12,\n        UINT32 = 13,\n        ENUM = 14,\n        SFIXED32 = 15,\n        SFIXED64 = 16,\n        SINT32 = 17,\n        SINT64 = 18,\n        FHASH64 = 30,\n        VHASH64 = 31,\n    }\n\n    enum WireType {\n        INVALID = -1,\n        VARINT = 0,\n        FIXED64 = 1,\n        DELIMITED = 2,\n        START_GROUP = 3,\n        END_GROUP = 4,\n        FIXED32 = 5,\n    }\n\n    const FieldTypeToWireType: (fieldType: FieldType) => WireType;\n\n    const INVALID_FIELD_NUMBER: number;\n    const FLOAT32_EPS: number;\n    const FLOAT32_MIN: number;\n    const FLOAT32_MAX: number;\n    const FLOAT64_EPS: number;\n    const FLOAT64_MIN: number;\n    const FLOAT64_MAX: number;\n    const TWO_TO_20: number;\n    const TWO_TO_23: number;\n    const TWO_TO_31: number;\n    const TWO_TO_32: number;\n    const TWO_TO_52: number;\n    const TWO_TO_63: number;\n    const TWO_TO_64: number;\n    const ZERO_HASH: string;\n}\n\nexport namespace arith {\n    class UInt64 {\n        lo: number;\n        hi: number;\n        constructor(lo: number, hi: number);\n        cmp(other: UInt64): number;\n        rightShift(): UInt64;\n        leftShift(): UInt64;\n        msb(): boolean;\n        lsb(): boolean;\n        zero(): boolean;\n        add(other: UInt64): UInt64;\n        sub(other: UInt64): UInt64;\n        static mul32x32(a: number, b: number): UInt64;\n        mul(a: number): UInt64;\n        div(divisor: number): [UInt64, UInt64];\n        toString(): string;\n        static fromString(str: string): UInt64;\n        clone(): UInt64;\n    }\n\n    class Int64 {\n        lo: number;\n        hi: number;\n        constructor(lo: number, hi: number);\n        add(other: Int64): Int64;\n        sub(other: Int64): Int64;\n        clone(): Int64;\n        toString(): string;\n        static fromString(str: string): Int64;\n    }\n}\n\n// jspb.utils package excluded as it likely shouldn't be called by user code\n"],"names":["BinaryDecoder","BinaryEncoder","BinaryIterator","BinaryReader","BinaryWriter","ExtensionFieldBinaryInfo","ExtensionFieldInfo","Map","Message","BinaryConstants","FieldType","WireType","FieldTypeToWireType","INVALID_FIELD_NUMBER","FLOAT32_EPS","FLOAT32_MIN","FLOAT32_MAX","FLOAT64_EPS","FLOAT64_MIN","FLOAT64_MAX","TWO_TO_20","TWO_TO_23","TWO_TO_31","TWO_TO_32","TWO_TO_52","TWO_TO_63","TWO_TO_64","ZERO_HASH","arith","UInt64","Int64"],"mappings":";;;;;;;;;;;;;;IAscaA,aAAa;eAAbA;;IAhCAC,aAAa;eAAbA;;IAmFAC,cAAc;eAAdA;;IA9PAC,YAAY;eAAZA;;IAkFAC,YAAY;eAAZA;;IAzKAC,wBAAwB;eAAxBA;;IAhBAC,kBAAkB;eAAlBA;;IAiCAC,GAAG;eAAHA;;IA5KSC,OAAO;eAAPA;;;;;;AAAf,IAAA,AAAeA,UAAf,MAAeA;AAoItB;AAOO,IAAA,AAAMF,qBAAN,MAAMA;AAcb;AAEO,IAAA,AAAMD,2BAAN,MAAMA;AAeb;AAEO,IAAA,AAAME,MAAN,MAAMA;AA8Cb;AAwBO,IAAA,AAAMJ,eAAN,MAAMA;AAgFb;AAEO,IAAA,AAAMC,eAAN,MAAMA;AAuFb;AAEO,IAAA,AAAMH,gBAAN,MAAMA;AA8Bb;AAEO,IAAA,AAAMD,gBAAN,MAAMA;AAiDb;AAEO,IAAA,AAAME,iBAAN,MAAMA;AAgBb;;UAEiBO;;cACRC;;;;;;;;;;;;;;;;;;;;;;OAAAA,cAAAA;;cAwBAC;;;;;;;;OAAAA,aAAAA;IAUL,MAAMC;IAEN,MAAMC;IACN,MAAMC;IACN,MAAMC;IACN,MAAMC;IACN,MAAMC;IACN,MAAMC;IACN,MAAMC;IACN,MAAMC;IACN,MAAMC;IACN,MAAMC;IACN,MAAMC;IACN,MAAMC;IACN,MAAMC;IACN,MAAMC;IACN,MAAMC;AACV,GApDiBlB,oBAAAA;;UAsDAmB;IACb,IAAA,AAAMC,SAAN,MAAMA;IAkBN;IAEA,IAAA,AAAMC,QAAN,MAAMA;IASN;AACJ,GA/BiBF,UAAAA,cAiCjB,4EAA4E"}