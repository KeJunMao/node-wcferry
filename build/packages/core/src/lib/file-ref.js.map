{"version":3,"sources":["../../../../../packages/core/src/lib/file-ref.ts"],"sourcesContent":["import os from 'os';\r\nimport { randomUUID } from 'crypto';\r\nimport { cp, rm, writeFile } from 'fs/promises';\r\nimport mime from 'mime';\r\nimport path from 'path';\r\nimport { URL } from 'url';\r\nimport { ensureDirSync } from './utils';\r\nimport { createWriteStream, existsSync } from 'fs';\r\nimport assert from 'assert';\r\nimport type { OutgoingHttpHeaders } from 'http';\r\n\r\nconst headers = {\r\n    'User-Agent':\r\n        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.127 Safari/537.36',\r\n};\r\n\r\nexport interface FileSavableInterface {\r\n    save(dir?: string): Promise<{ path: string; discard: () => Promise<void> }>;\r\n}\r\n\r\nexport class FileRef implements FileSavableInterface {\r\n    /**\r\n     * @param location location of the resource. can be\r\n     * - a local path\r\n     * - a link starts with `http(s)://`\r\n     * - a buffer\r\n     *\r\n     * Note: base64 string can be convert to buffer by: `Buffer.from('content', 'base64')`\r\n     * Note: if input is a Buffer, it would be nice to have a name with correct extension in the options,\r\n     * or a common name `<uuid>.dat` will be used\r\n     */\r\n    constructor(\r\n        private readonly location: string | Buffer,\r\n        private readonly options: {\r\n            name?: string;\r\n            headers?: OutgoingHttpHeaders;\r\n        } = {}\r\n    ) {}\r\n\r\n    private isUrl(loc: string) {\r\n        return /^https?:\\/\\//.test(loc);\r\n    }\r\n\r\n    /**\r\n     * save the file into dir with name and extension inferred\r\n     * @param dir the saving directory, defaults to `os.tmpdir()`\r\n     * @param cpLocal when the source is local file, if we copy it to dir or directly return the source path\r\n     * @returns\r\n     */\r\n    async save(\r\n        dir = os.tmpdir(),\r\n        cpLocal = false\r\n    ): Promise<{ path: string; discard: () => Promise<void> }> {\r\n        ensureDirSync(dir);\r\n        if (Buffer.isBuffer(this.location)) {\r\n            return this.wrapWithDiscard(\r\n                await this.saveFromBase64(dir, this.location)\r\n            );\r\n        }\r\n        if (this.isUrl(this.location)) {\r\n            const p = await this.saveFromUrl(dir, new URL(this.location));\r\n            return this.wrapWithDiscard(p);\r\n        }\r\n\r\n        if (cpLocal) {\r\n            return this.wrapWithDiscard(await this.saveFromFile(dir));\r\n        }\r\n        // if file existed in local, we direct use it\r\n        return {\r\n            path: this.location,\r\n            discard: () => Promise.resolve(),\r\n        };\r\n    }\r\n\r\n    wrapWithDiscard(p: string) {\r\n        return {\r\n            path: p,\r\n            discard: () => rm(p, { force: true }),\r\n        };\r\n    }\r\n\r\n    private getName(opt?: { mimeType?: string; inferredName?: string }) {\r\n        const basename = this.options.name ?? opt?.inferredName ?? randomUUID();\r\n        let ext = path.extname(basename);\r\n        if (ext) {\r\n            return basename;\r\n        }\r\n        ext = 'dat';\r\n        if (opt?.mimeType) {\r\n            ext = mime.getExtension(opt.mimeType) ?? ext;\r\n        }\r\n        return `${basename}.${ext}`;\r\n    }\r\n\r\n    private getSavingPath(dir: string, name: string): string {\r\n        const extname = path.extname(name);\r\n        const basename = path.basename(name, extname);\r\n        for (let i = 0; ; i++) {\r\n            const suffix = i === 0 ? '' : `-${i}`;\r\n            const p = path.join(dir, `${basename}${suffix}${extname}`);\r\n            if (!existsSync(p)) {\r\n                return p;\r\n            }\r\n        }\r\n    }\r\n\r\n    private async saveFromBase64(dir: string, buffer: Buffer): Promise<string> {\r\n        const binary = buffer.toString('binary');\r\n        const name = this.getName();\r\n        const fullpath = this.getSavingPath(dir, name);\r\n        await writeFile(fullpath, binary, 'binary');\r\n        return fullpath;\r\n    }\r\n\r\n    private async saveFromUrl(dir: string, url: URL): Promise<string> {\r\n        const basename = path.basename(url.pathname);\r\n        let fullpath: string | undefined;\r\n        const http =\r\n            url.protocol === 'https:'\r\n                ? await import('https')\r\n                : await import('http');\r\n        return await new Promise<string>((resolve, reject) => {\r\n            http.get(url, { headers }, (response) => {\r\n                const probeName =\r\n                    response.headers['content-disposition']?.match(\r\n                        /attachment; filename=\"?(.+[^\"])\"?$/i\r\n                    )?.[1] ?? basename;\r\n\r\n                const mimeType = response.headers['content-type'];\r\n                const name = this.getName({\r\n                    mimeType,\r\n                    inferredName: probeName,\r\n                });\r\n                fullpath = this.getSavingPath(dir, name);\r\n                const file = createWriteStream(fullpath);\r\n                response.pipe(file);\r\n\r\n                file.on('finish', () => {\r\n                    file.close();\r\n                    resolve(fullpath!);\r\n                });\r\n            }).on('error', (error) => {\r\n                if (fullpath) {\r\n                    rm(fullpath, { force: true }).finally(() => {\r\n                        reject(error.message);\r\n                    });\r\n                } else {\r\n                    reject(error.message);\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    private async saveFromFile(dir: string): Promise<string> {\r\n        assert(typeof this.location === 'string', 'impossible');\r\n        if (!existsSync(this.location)) {\r\n            return Promise.reject(\r\n                new Error(`Source file ${this.location} doesn't exist`)\r\n            );\r\n        }\r\n        const name = this.getName({\r\n            inferredName: path.basename(this.location),\r\n        });\r\n        const saved = this.getSavingPath(dir, name);\r\n\r\n        await cp(this.location, saved, { force: true });\r\n        return saved;\r\n    }\r\n}\r\n"],"names":["FileRef","headers","isUrl","loc","test","save","dir","os","tmpdir","cpLocal","ensureDirSync","Buffer","isBuffer","location","wrapWithDiscard","saveFromBase64","p","saveFromUrl","URL","saveFromFile","path","discard","Promise","resolve","rm","force","getName","opt","basename","options","name","inferredName","randomUUID","ext","extname","mimeType","mime","getExtension","getSavingPath","i","suffix","join","existsSync","buffer","binary","toString","fullpath","writeFile","url","pathname","http","protocol","reject","get","response","probeName","match","file","createWriteStream","pipe","on","close","error","finally","message","assert","Error","saved","cp","constructor"],"mappings":"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"}